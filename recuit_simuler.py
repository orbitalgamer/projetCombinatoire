# -*- coding: utf-8 -*-
"""opti combi - projet square root rank.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZXNhyCQTIiKr94WOZSZOJ12rXZs8HsnT
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from joblib import Parallel, delayed

from utils import LEDM, random_matrix, ecrire_fichier

from backup import init_johan

# from metaheuristic_johan import init_johan

import warnings
warnings.filterwarnings("ignore")

from collections import deque



def matrices1_ledm(n):
  M  = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      M[i,j]=(i-j)**2
  return M

from scipy.linalg import circulant
def matrices2_slackngon(n):
  M  = circulant(np.cos(np.pi/n)-np.cos(np.pi/n + 2*np.pi*np.arange(0,n,1)/n))
  M /= M[0,2]
  M  = np.maximum(M,0)
  for i in range(n):
    M[i,i] = 0
    if i<n-1:
      M[i,i+1] = 0
    else:
      M[i,0] = 0
  return M

def fobj(M,P,tol=1e-10, all_sng=False, verbose=False):
  sing_values = np.linalg.svd(P*np.sqrt(M), compute_uv=False)    # Calcul des valeurs singulières de la matrice P.*sqrt(M)
  tol         = max(M.shape)*sing_values[0]*np.finfo(float).eps  # Calcul de la tolérance à utiliser pour la matrice P*sqrt(M)
  ind_nonzero = np.where(sing_values > tol)[0]                   # indices des valeurs > tolérance
  if verbose:
      print(f"tol = {tol} and worst sing value = {sing_values[ind_nonzero[-1]]}")
  return len(ind_nonzero), sing_values[ind_nonzero[-1]]  



def compareP1betterthanP2(M,P1,P2):
  r1, s1 = fobj(M,P1) #on récupère les deux objectifs pour le pattern P1
  r2, s2 = fobj(M,P2) #on récupère les deux objectifs pour le pattern P2
  if r1 != r2:        #on traite les objectifs de façon lexicographique :
      return r1 < r2  # d'abord les valeurs du rang, et si celles-ci sont égales
  return s1 < s2      # alors on prend en compte la valeur de la + petite valeur singulière

def metaheuristic(M):
  bestPattern = np.ones(M.shape) #pattern initial

  ... #votre méthode

  return bestPattern

M = np.array([[4,0,1],[1,1,1],[1,1,0]])
P1 = np.array([[1,1,-1],[-1,1,1],[1,-1,-1]])
P2 = np.array([[-1,1,-1],[-1,-1,1],[1,1,-1]])
# print(compareP1betterthanP2(M,P1,P2))
# print(np.linalg.svd(P1*np.sqrt(M), compute_uv=False))

# M = matrices2_slackngon(7)
# P = np.array([[1,1,1,1,1,-1,1],[1,1,1,-1,1,-1,1],[1,1,1,1,1,1,-1],[1,-1,1,1,1,-1,-1],[1,1,-1,1,1,1,1],[1,-1,1,-1,-1,1,1],[1,1,1,1,1,1,1]])
# print(fobj(M,P))


def clustering_lines(M, n_clusters):
    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    labels = kmeans.fit_predict(M)
    return labels

def clustering_columns(M, n_clusters):
    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    labels = kmeans.fit_predict(M.T)
    return labels

def generate_initial_P(M, n_cluster):
    line_labels = clustering_lines(M, n_clusters=n_cluster)
    col_labels = clustering_columns(M, n_clusters=n_cluster)
    P = np.zeros_like(M)
    
    for i in range(M.shape[0]):
        for j in range(M.shape[1]):
            P[i, j] = 1 if (line_labels[i] + col_labels[j]) % 2 == 0 else -1
    return P


def generate_P_pair_wise(M):
    P= np.zeros(M.shape)
    for j in range(P.shape[0]):
        for i in range(P.shape[1]):
            if M[j,i] != 0:
                if (i+j)%2:
                    P[j,i]=-1
                else:
                    P[j,i]=1
    return P





def recuit_simule(Mprime, Pinit=None, test=False, verbose=False):
    def get_hash(m):
        return hash(m.tobytes())

    
    cluster = 2
    
    initP = generate_initial_P(Mprime, cluster)
    # initP = generate_P_pair_wise(Mprime)
    initP = init_johan(Mprime, initP, 4)
    # initP = np.ones(Mprime.shape)
    # initP = np.random.choice([-1,1], size=Mprime.shape)
    if test== True:
        initP=Pinit
    
    Tinit = 1000
    Tf = 1e-6
    alpha = 0.90
    best = np.zeros(Mprime.shape)
    best_rank = np.inf
    best_sing_value = np.inf
    current = initP.copy()
    # current = np.ones(Mprime.shape)
    current_rank = np.inf
    current_sing_value = np.inf
    
    tmp = np.ones(Mprime.shape)
    
    

    previous_score = np.inf
    
    palier = 200
    
    n_permut = 1
    
    superPalier = 20
    superPalierCount = 0
    
    
    
    amelioration = 0
    
    Temperature = Tinit
    while Temperature>Tf:
        
        
        for _ in range(palier):
            tmp = current.copy() #backup
            choix= random.randrange(0,3)
            # choix = 
            if choix == 0:    
                i = random.randrange(current.shape[0])
                j = random.randrange(current.shape[1])
                tmp[i,j] *= -1
            elif choix == 1:
                i = random.randrange(current.shape[0])
                tmp[i,:] *= -1
            elif choix == 2:
                j = random.randrange(current.shape[1])
                tmp[:,j] *= -1
      
            # tmp  = np.random.choice([-1,1], size=Mprime.shape)
            tmp_rank, tmp_sing_value = fobj(Mprime, tmp)
            
            
            #si meilleur stock
            if tmp_rank<current_rank or (tmp_rank == current_rank and tmp_sing_value<=current_sing_value):
                # print("here")
                current = tmp.copy()
                current_rank = tmp_rank
                current_sing_value = tmp_sing_value
            else:
                if tmp_rank == current_rank:
                    proba = np.exp(-((tmp_sing_value-current_sing_value)*100/current_sing_value)/Temperature)
                    # print(((tmp_sing_value-current_sing_value)/current_sing_value))
                else:
                    proba = np.exp(-(tmp_rank-current_rank)*10/Temperature)
                    
                #     print((tmp_rank-current_rank)*10)
                # print(proba, Temperature)
                if random.random() < proba:#accepta alors
                    current = tmp.copy()
                    current_rank = tmp_rank
                    current_sing_value = tmp_sing_value
                    
            #stock le best
            if best_rank>current_rank or (best_rank == current_rank and best_sing_value>current_sing_value):
                best = current.copy()
                best_rank = current_rank
                best_sing_value = current_sing_value
                if verbose: print(f" better found !  best_rank={best_rank}, best_sing = {best_sing_value}")
                # fobj(Mprime, best, all_sng=True)
                amelioration =0
        if best_rank == 2:
            break
        amelioration+=1
        if amelioration > 5: #recharge meilleur si avance plus
            current=best.copy()
            current_sing_value = best_sing_value
            current_rank = best_rank
            amelioration=0
            # print("rechargement")
            
        Temperature *= alpha
        if(superPalierCount < superPalier and not Temperature>Tf):
            Temperature=Tinit
            superPalierCount+=1
            if verbose: print(f"new palier and current rank = {current_rank} and best_rank={best_rank}, best_sing = {best_sing_value}")
            
        # print(f"Temperature = {Temperature}, current rank = {current_rank}, best_rank={best_rank}, best_sing = {best_sing_value}")
    return best
# print(f"best_rank = {best_rank} avec sing value = {best_sing_value}")
# print(best)


def split_matrix_into_blocks(M):
    """
    Découpe la matrice M en 4 sous-matrices de taille approximativement égale.
    Retourne les sous-matrices A, B, C, D.
    """
    rows, cols = M.shape
    mid_row, mid_col = rows // 2, cols // 2  # Calcul des indices centraux
    
    # Découpage en blocs
    A = M[:mid_row, :mid_col]      # Haut gauche
    B = M[:mid_row, mid_col:]      # Haut droit
    C = M[mid_row:, :mid_col]      # Bas gauche
    D = M[mid_row:, mid_col:]      # Bas droit
    
    return A, B, C, D


def split_matrix_with_padding(matrix, block_size, padding_value=0):
    rows, cols = matrix.shape
    block_rows, block_cols = block_size

    # Calcul des nouvelles dimensions (avec padding si nécessaire)
    padded_rows = ((rows + block_rows - 1) // block_rows) * block_rows
    padded_cols = ((cols + block_cols - 1) // block_cols) * block_cols

    # Ajouter du padding
    padded_matrix = np.full((padded_rows, padded_cols), padding_value, dtype=matrix.dtype)
    padded_matrix[:rows, :cols] = matrix

    # Diviser la matrice remplie en blocs
    blocks = [
        padded_matrix[i:i+block_rows, j:j+block_cols]
        for i in range(0, padded_rows, block_rows)
        for j in range(0, padded_cols, block_cols)
    ]
    return blocks, (padded_rows, padded_cols)  # Retourne aussi la nouvelle taille

def reconstruct_matrix_without_padding(blocks, original_shape, block_size):
    rows, cols = original_shape
    block_rows, block_cols = block_size

    # Calcul des dimensions de la matrice avec padding
    padded_rows = ((rows + block_rows - 1) // block_rows) * block_rows
    padded_cols = ((cols + block_cols - 1) // block_cols) * block_cols

    # Reconstituer la matrice remplie
    reconstructed_matrix = np.zeros((padded_rows, padded_cols), dtype=blocks[0].dtype)
    idx = 0
    for i in range(0, padded_rows, block_rows):
        for j in range(0, padded_cols, block_cols):
            reconstructed_matrix[i:i+block_rows, j:j+block_cols] = blocks[idx]
            idx += 1

    # Supprimer le padding
    return reconstructed_matrix[:rows, :cols]


Mprime = np.array([[16,4,1,25,4], [16,4,4,36,0], [0,0,9,1,4], [36,9,0,64,4], [16,4,1,25,4], [4,1,49,25,16]])
# Mprime = matrices2_slackngon(70)
Mprime=LEDM(70, 70)
# Mprime = random_matrix(20, 20, 5)
block_size = (7,7)

# Mprime = random_matrix(32,32,10)


# print("start")
# chunks = split_matrix_into_blocks(Mprime)
# # chunks = split_matrix_with_padding(Mprime, block_size)  # adjust chunk size based on available cores

# results = Parallel(n_jobs=4)(delayed(recuit_simule)(chunk) for chunk in chunks)

# print("end")

# top = np.hstack((results[0], results[1]))
# bottom = np.hstack((results[2], results[3]))
# Ptotal= np.vstack((top, bottom))

# Ptotal = reconstruct_matrix(results, Mprime.shape, block_size)


# total_rank, total_sing_value = fobj(Mprime, Ptotal)
Ptotal = np.zeros((1,1))
best_p = recuit_simule(Mprime, Ptotal.copy(), False, verbose=True)

total_rank_2, total_sing_value_2 = fobj(Mprime, best_p, verbose=True)
# print(f"avant recuit best_rank = {total_rank} avec sing value = {total_sing_value}")
print(f"après recuit best_rank = {total_rank_2} avec sing value = {total_sing_value_2}")

ecrire_fichier("test70LEDM.txt", Mprime, best_p)

best_p_prime = init_johan(Mprime, best_p, 4)
total_rank_3, total_sing_value_3 = fobj(Mprime, best_p_prime, verbose=True)
print(f"après recuit best_rank = {total_rank_3} avec sing value = {total_sing_value_3}")


    