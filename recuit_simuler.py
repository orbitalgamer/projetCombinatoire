# -*- coding: utf-8 -*-
"""opti combi - projet square root rank.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZXNhyCQTIiKr94WOZSZOJ12rXZs8HsnT
"""

import numpy as np
import random
import matplotlib.pyplot as plt


from utils import LEDM

def matrices1_ledm(n):
  M  = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      M[i,j]=(i-j)**2
  return M

from scipy.linalg import circulant
def matrices2_slackngon(n):
  M  = circulant(np.cos(np.pi/n)-np.cos(np.pi/n + 2*np.pi*np.arange(0,n,1)/n))
  M /= M[0,2]
  M  = np.maximum(M,0)
  for i in range(n):
    M[i,i] = 0
    if i<n-1:
      M[i,i+1] = 0
    else:
      M[i,0] = 0
  return M

def fobj(M,P,tol=1e-14):
  sing_values = np.linalg.svd(P*np.sqrt(M), compute_uv=False) # Calcul des valeurs singulières de la matrice P.*sqrt(M)
  ind_nonzero = np.where(sing_values > tol)[0]                # indices des valeurs > tolérance donnée
  return len(ind_nonzero), sing_values[ind_nonzero[-1]]       # on retourne objectif1=rang et objectif2=plus petite val sing. non-nulle

def compareP1betterthanP2(M,P1,P2):
  r1, s1 = fobj(M,P1) #on récupère les deux objectifs pour le pattern P1
  r2, s2 = fobj(M,P2) #on récupère les deux objectifs pour le pattern P2
  if r1 != r2:        #on traite les objectifs de façon lexicographique :
      return r1 < r2  # d'abord les valeurs du rang, et si celles-ci sont égales
  return s1 < s2      # alors on prend en compte la valeur de la + petite valeur singulière

def metaheuristic(M):
  bestPattern = np.ones(M.shape) #pattern initial

  ... #votre méthode

  return bestPattern

M = np.array([[4,0,1],[1,1,1],[1,1,0]])
P1 = np.array([[1,1,-1],[-1,1,1],[1,-1,-1]])
P2 = np.array([[-1,1,-1],[-1,-1,1],[1,1,-1]])
print(compareP1betterthanP2(M,P1,P2))
print(np.linalg.svd(P1*np.sqrt(M), compute_uv=False))

# M = matrices2_slackngon(7)
# P = np.array([[1,1,1,1,1,-1,1],[1,1,1,-1,1,-1,1],[1,1,1,1,1,1,-1],[1,-1,1,1,1,-1,-1],[1,1,-1,1,1,1,1],[1,-1,1,-1,-1,1,1],[1,1,1,1,1,1,1]])
# print(fobj(M,P))

Mprime = np.array([[16,4,1,25,4], [16,4,4,36,0], [0,0,9,1,4], [36,9,0,64,4], [16,4,1,25,4], [4,1,49,25,16]])

Mprime=LEDM(20, 15)

Tinit = 100
Tf = 1e-18
alpha = 0.9
best = np.zeros(Mprime.shape)
best_rank = np.inf
best_sing_value = np.inf
current = np.random.choice([-1,1], size=Mprime.shape)
# current = np.ones(Mprime.shape)
current_rank = np.inf
current_sing_value = np.inf

tmp = np.ones(Mprime.shape)

previous_score = np.inf

palier = 500

n_permut = 10

superPalier = 100
superPalierCount = 0

alltest = []

Temperature = Tinit
while Temperature>Tf:
    tmp = current.copy() #backup
    
    for _ in range(palier):
        choix= random.randrange(4)
        if choix == 0:    
            i = random.randrange(current.shape[0])
            j = random.randrange(current.shape[1])
            tmp[i,j] *= -1
        elif choix == 1:
            i = random.randrange(current.shape[0])
            tmp[i,:] *= -1
        elif choix == 2:
            j = random.randrange(current.shape[1])
            tmp[:,j] *= -1
  
        # tmp  = np.random.choice([-1,1], size=Mprime.shape)
        tmp_rank, tmp_sing_value = fobj(Mprime, tmp)
        alltest.append(tmp_sing_value)
        
        #si meilleur stock
        if tmp_rank<current_rank or (tmp_rank == current_rank and tmp_sing_value<=current_sing_value):
            # print("here")
            current = tmp.copy()
            current_rank = tmp_rank
            current_sing_value = tmp_sing_value
        else:
            if tmp_rank == current_rank:
                proba = np.exp(-((tmp_sing_value-current_sing_value)/current_sing_value)/Temperature)
                # print(((tmp_sing_value-current_sing_value)/current_sing_value))
            else:
                proba = np.exp(-(tmp_rank-current_rank)*10/Temperature)
                
            #     print((tmp_rank-current_rank)*10)
            # print(proba, Temperature)
            if random.random() < proba:#accepta alors
                current = tmp.copy()
                current_rank = tmp_rank
                current_sing_value = tmp_sing_value
                
        #stock le best
        if best_rank>current_rank or (best_rank == current_rank and best_sing_value>current_sing_value):
            best = current.copy()
            best_rank = current_rank
            best_sing_value = current_sing_value
            print(f" better found !  best_rank={best_rank}, best_sing = {best_sing_value}")
    Temperature *= alpha
    if(superPalierCount < superPalier and not Temperature>Tf):
        Temperature=Tinit
        superPalierCount+=1
        print(f"new palier and current rank = {current_rank} and best_rank={best_rank}, best_sing = {best_sing_value}")

    # print(f"Temperature = {Temperature}, current rank = {current_rank}, best_rank={best_rank}, best_sing = {best_sing_value}")
    
print(f"best_rank = {best_rank} avec sing value = {best_sing_value}")


    
        
    